import { getRandomId } from "@cf/base/utils";
import { questionTemplateSchema } from "@cf/core/question-bank";
import {
  originOwner,
  originRepo,
  upstreamOwner,
  upstreamRepo,
} from "../common/env";
import type { EditQuestionsPr } from "@cf/core/github";
import type { QuestionTemplate } from "@cf/core/question-bank";
import type { Octokit } from "octokit";

const normalizePath = (src: string) =>
  src.replace(/\\/g, "/").replace(/^\//, "");

export const createEditQuestionsPr = async (
  octokit: Octokit,
  state: EditQuestionsPr,
) => {
  const prId = getRandomId();
  const baseBranch = "main";
  const newBranch = `feat-edit-questions-${state.questionBank}-${prId}`;
  const deletedIds = state.deletedQuestions.map((id) => id.toString());

  const baseBranchRef = await octokit.rest.git.getRef({
    owner: originOwner,
    repo: originRepo,
    ref: `heads/${baseBranch}`,
  });

  const newBranchRef = await octokit.rest.git.createRef({
    owner: originOwner,
    repo: originRepo,
    ref: `refs/heads/${newBranch}`,
    sha: baseBranchRef.data.object.sha,
  });

  const currentCommit = await octokit.rest.git.getCommit({
    owner: originOwner,
    repo: originRepo,
    commit_sha: newBranchRef.data.object.sha,
  });

  const srcLocations = [
    ...new Set([
      ...state.questions.map((q) => normalizePath(q.srcLocation)),
      ...state.questions.map((q) => normalizePath(q.srcLocation)),
    ]),
  ];

  const githubQuestions: QuestionTemplate[] = [];
  for (const srcLocation of srcLocations) {
    const getContentResponse = await octokit.rest.repos.getContent({
      owner: originOwner,
      repo: originRepo,
      path: srcLocation,
      ref: baseBranchRef.data.object.sha,
      mediaType: {
        format: "raw",
      },
    });

    const assumedString = getContentResponse.data as unknown as string;
    const assumedArray = JSON.parse(assumedString);
    const newQuestions = questionTemplateSchema.array().parse(assumedArray);
    githubQuestions.push(...newQuestions);
  }

  const modifiedQuestions = githubQuestions
    .map((q) => {
      const deleted = deletedIds.includes(q.id);
      if (deleted) return null;

      const newQuestion = state.questions.find((sq) => sq.id === q.id);
      if (newQuestion) return newQuestion;

      return q;
    })
    .filter(Boolean);

  const newFileContents = modifiedQuestions.reduce(
    (acc, q) => {
      const srcLocation = normalizePath(q.srcLocation);
      acc[srcLocation] ??= [];
      acc[srcLocation].push(q);
      return acc;
    },
    {} as Record<string, QuestionTemplate[]>,
  );

  const newFiles = Object.keys(newFileContents).map((srcLocation) => {
    const newFile = JSON.stringify(newFileContents[srcLocation], null, 2);
    return { srcLocation, newFile };
  });

  const newTree = await octokit.rest.git.createTree({
    owner: originOwner,
    repo: originRepo,
    base_tree: currentCommit.data.tree.sha,
    tree: newFiles.map(({ srcLocation, newFile }) => ({
      path: srcLocation,
      mode: "100644",
      type: "blob",
      content: newFile,
    })),
  });

  const title = `content(${state.questionBank}): ${state.meta.title}`;
  const body = [
    "Automatic PR generated by Chair Flight.",
    "",
    "## User Provided context",
    "",
    `> ### ${state.meta.title ?? "No title provided"}`,
    "",
    ...state.meta.description.split("\n").map((line) => `> ${line}`),
    "",
  ].join("\n");

  const newCommit = await octokit.rest.git.createCommit({
    owner: originOwner,
    repo: originRepo,
    author: {
      name: state.meta.authorName || "Chair Flight Bot",
      email: state.meta.email || "bot@cf.com",
    },
    message: `${title}\n\n${body}`,
    tree: newTree.data.sha,
    parents: [currentCommit.data.sha],
  });

  await octokit.rest.git.updateRef({
    owner: originOwner,
    repo: originRepo,
    ref: `heads/${newBranch}`,
    sha: newCommit.data.sha,
  });

  const response = await octokit.rest.pulls.create({
    owner: upstreamOwner,
    repo: upstreamRepo,
    head: originOwner + ":" + newBranch,
    base: baseBranch,
    title,
    body,
    author: {
      name: "Chair Flight Bot",
      email: "bot@cf.com",
    },
  });

  return { url: response.data.html_url };
};
